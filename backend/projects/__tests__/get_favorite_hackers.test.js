// tests for get_favorite_hackers
// Generated by serverless-jest-plugin

const mod = require('../handler');

const jestPlugin = require('serverless-jest-plugin');
const lambdaWrapper = jestPlugin.lambdaWrapper;
const adder = lambdaWrapper.wrap(mod, { handler: 'add_favorite_hacker' });
const wrapped = lambdaWrapper.wrap(mod, { handler: 'get_favorite_hackers' });

const AWS = require('aws-sdk');
const UUID = require('uuid');
const sponsor = UUID.v4();

const example_favorite_hacker1 = {
  body: JSON.stringify({
    sponsor_id: sponsor,
    user_id: UUID.v4(),
  }),
};

const example_favorite_hacker2 = {
  body: JSON.stringify({
    sponsor_id: sponsor,
    user_id: UUID.v4(),
  }),
};

const get_request = {
  queryStringParameters: { sponsor_id: sponsor },
  KeyConditionExpression: 'sponsor_id = :s',
  ExpressionAttributeValues: { ':s': sponsor, },
};

describe('get_favorite_hackers', () => {
  beforeAll((done) => {
    done();
  });

  // Since the get_request will be for a new sponsor, the FAVORITE_HACKERS_TABLE doesn't have to be empty
  it('Check for empty list when there are no favorite hackers', async () => {
    return await wrapped.run(get_request).then(async (response) => {
      expect(response).toBeDefined();
      expect(response).toHaveProperty('statusCode', 200);
      expect(response.body === '[]').toBeTruthy();
    });
  });

  it('Correctly lists all favorite hackers for sponsor', async () => {
    await adder.run(example_favorite_hacker1);
    await adder.run(example_favorite_hacker2);
    
    return await wrapped.run(get_request).then(async (response) => {
      expect(response).toBeDefined();
      expect(response).toHaveProperty('statusCode', 200);

      const expected = [JSON.parse(example_favorite_hacker1.body), JSON.parse(example_favorite_hacker2.body)];
      const received = JSON.parse(response.body);

      // sort both arrays with same condition to prevent any inconsistencies
      expected.sort((a,b)=> (a.user_id > b.user_id ? 1 : -1));
      received.sort((a,b)=> (a.user_id > b.user_id ? 1 : -1));

      var i;
      for (i = 0; i < received.length; i++) {
        expect(received[i]).toMatchObject(expected[i]);
      }
    });
  });
});

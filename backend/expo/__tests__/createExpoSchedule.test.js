// tests for createExpoSchedule
// Generated by serverless-jest-plugin

const fs = require('fs');
const AwsMock = require('aws-sdk-mock');
const jestPlugin = require('serverless-jest-plugin');
const UUID = require('uuid');
const mod = require('../handler');

const MIN_TIME = 5;
const MAX_TIME = 10;

AwsMock.mock('config', 'update', jest.fn());
const wrapped = jestPlugin.lambdaWrapper.wrap(mod, { handler: 'createExpoSchedule' });

const sponsors = [
  { name: 'M&T Bank', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Technica', demoSession: 3, zoomLink: 'https://zoom.us/' },
  { name: 'Bloomberg', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'JP Morgan Chase', demoSession: 3, zoomLink: 'https://zoom.us/' },
  { name: 'Visionist', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Facebook', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Capital One', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Fannie Mae', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'MLH', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Nextdoor', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Google', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Qualcomm', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Dingman Center', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'FINRA', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Adobe', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Tenable', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Cisco', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Cvent', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Splunk', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Qualtrics', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Coding it Forward', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'TripAdvisor', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Altamira', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'T. Rowe Price', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'Goldman Sachs', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'ASRC Federal', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'FiscalNote', demoSession: 2, zoomLink: 'https://zoom.us/' },
  { name: 'Algorand', demoSession: 1, zoomLink: 'https://zoom.us/' },
  { name: 'VistaPrint', demoSession: 2, zoomLink: 'https://zoom.us/' },
];

const expoStart = '2020-10-25T16:00:00Z';
const expoEnd = '2020-10-25T19:00:00Z';

const expoEvent = [{
  category: 'main',
  start_time: expoStart,
  end_time: expoEnd,
  description: 'Demo sessions!',
  id: '100',
  zoom_link: 'https://zoom.us/test',
  event_name: 'Expo',
}];

const uploadMock = jest.fn().mockImplementation((params, callback) => callback());
const consoleSpy = jest.spyOn(console, 'error');

/**
 * Does the following checks on the demo schedule
 * - Has the right number of projects
 * - No project has the same sponsor multiple times
 * - Each project doesn't have overlapping demos
 *
 * @param demos A list of demo which would be sent to the db
 * @param numProjs The expected number of projects
 */
function checkDemoSchedule(demos, numProjs) {
  const projects = {};
  demos.forEach((demo) => {
    const teamId = demo.PutRequest.Item.team_id;
    if (!(teamId in projects)) {
      projects[teamId] = [];
    }
    projects[teamId].push(demo.PutRequest.Item);
    expect(demo.PutRequest.Item.team_id).toBeDefined();
    expect(demo.PutRequest.Item.sponsor_name).toBeDefined();
    expect(demo.PutRequest.Item.start_time).toBeDefined();
    expect(demo.PutRequest.Item.end_time).toBeDefined();
    expect(demo.PutRequest.Item.zoom_link).toBeDefined();
  });

  // Check there are the right number of projects
  expect(Object.keys(projects)).toHaveLength(numProjs);

  Object.keys(projects).forEach((projectName) => {
    const projectData = projects[projectName];

    // Each sponsor should be unique
    const projectSponsors = new Set(projectData.map((d) => d.sponsor_name));
    expect(projectSponsors.size).toBe(projectData.length);

    let lastEndTime = null;
    // Adding random day so the time can be treated as a date
    projectData.sort((a, b) => (new Date(b.end_time) < new Date(a.end_time) ? 1 : -1))
      .forEach((project) => {
        // Checks that the end time of the last demo is before the next start time
        if (lastEndTime != null) {
          expect(new Date(project.start_time) >= lastEndTime).toBeTruthy();
          expect(new Date(project.start_time) >= new Date(expoStart)).toBeTruthy();
          expect(new Date(project.end_time) <= new Date(expoEnd)).toBeTruthy();
        }
        lastEndTime = new Date(project.end_time);
      });
  });
}

/**
 * Goes through each demo and makes sure that each demo length is the correct length
 *
 * @param demos A list of demo which would be sent to the db
 * @param length The expected length of the demo
 */
function checkDemoLength(demos, length) {
  let correctLength = true;

  demos.forEach((demo) => {
    const startDate = new Date(demo.PutRequest.Item.start_time);
    const endDate = new Date(demo.PutRequest.Item.end_time);
    if ((endDate - startDate) / 60000 !== length) {
      correctLength = false;
    }
  });

  // Check if the time is right
  expect(correctLength).toBeTruthy();
}

/**
 * Goes through each demo and makes sure that each demo length has the team name
 *
 * @param demos A list of demo which would be sent to the db
 */
function checkDemoNames(demos) {
  let hasNames = true;

  demos.forEach((demo) => {
    if (demo.PutRequest.Item.team_name === undefined) {
      hasNames = false;
    }
  });

  // Check if the there are names
  expect(hasNames).toBeTruthy();
}

describe('createExpoSchedule', () => {
  beforeAll((done) => {
    done();
  });

  beforeEach(() => {
    AwsMock.mock('DynamoDB.DocumentClient', 'scan', (params, callback) => {
      if (params.TableName === process.env.SCHEDULE_TABLE) {
        return callback(null, { Items: expoEvent });
      } if (params.TableName === process.env.SPONSORS_INFO_TABLE) {
        return callback(null, { Items: sponsors });
      } if (params.TableName === process.env.DEVPOST_LINK_TABLE) {
        return callback(null, { Items: [{ team_id: UUID.v4() }] });
      }
      return callback();
    });
    AwsMock.mock('DynamoDB.DocumentClient', 'batchWrite', uploadMock);
  });

  afterEach(() => {
    AwsMock.restore();
    uploadMock.mockClear();
    consoleSpy.mockClear();
  });

  it('works with small submissions', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions1.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);
    expect(uploadMock).toHaveBeenCalledTimes(1);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    const params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');
    // Check the right number of rows were added
    expect(params.RequestItems['platform-test-expo-schedule']).toHaveLength(9);

    checkDemoSchedule(params.RequestItems['platform-test-expo-schedule'], 5);
  });

  it('works with technica\'s submissions', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions2.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);
    expect(uploadMock).toHaveBeenCalledTimes(15);
    expect(consoleSpy).toHaveBeenCalledTimes(0);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    let params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');

    const allCalls = [];
    uploadMock.mock.calls.forEach((call) => {
      [params] = call;
      allCalls.push(...params.RequestItems['platform-test-expo-schedule']);
    });
    // Check the right number of rows were added
    expect(allCalls).toHaveLength(352);

    checkDemoSchedule(allCalls, 135);
  });

  it('uses multiple demo sessions', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions3.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);
    expect(uploadMock).toHaveBeenCalledTimes(2);
    expect(consoleSpy).toHaveBeenCalledTimes(0);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    let params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');

    const allCalls = [];
    uploadMock.mock.calls.forEach((call) => {
      [params] = call;
      allCalls.push(...params.RequestItems['platform-test-expo-schedule']);
    });
    // Check the right number of rows were added
    expect(allCalls).toHaveLength(40);

    checkDemoSchedule(allCalls, 40);
  });

  it('uses multiple submissions to same sponsor', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions4.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);
    expect(uploadMock).toHaveBeenCalledTimes(1);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    const params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');
    // Check the right number of rows were added
    expect(params.RequestItems['platform-test-expo-schedule']).toHaveLength(2);

    checkDemoSchedule(params.RequestItems['platform-test-expo-schedule'], 1);
  });

  it('not enough demo slots for sponsor', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions5.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);
    expect(uploadMock).toHaveBeenCalledTimes(2);
    expect(consoleSpy).toHaveBeenCalledTimes(4);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    let params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');

    const allCalls = [];
    uploadMock.mock.calls.forEach((call) => {
      [params] = call;
      allCalls.push(...params.RequestItems['platform-test-expo-schedule']);
    });
    // Check the right number of rows were added
    expect(allCalls).toHaveLength(36);

    checkDemoSchedule(allCalls, 36);
  });

  it('is missing Expo event', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions1.csv')));

    AwsMock.restore('DynamoDB.DocumentClient', 'scan');
    AwsMock.mock('DynamoDB.DocumentClient', 'scan', (params, callback) => {
      if (params.TableName === process.env.SCHEDULE_TABLE) {
        return callback(null, { Items: {} });
      } if (params.TableName === process.env.SPONSORS_INFO_TABLE) {
        return callback(null, { Items: sponsors });
      }
      return callback();
    });

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 500);
    expect(JSON.parse(response.body).message).toBe('Error: Missing Expo event in platform-test-schedule');
  });

  it('is missing event body keys', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions1.csv')));

    const response = await wrapped.run({ body: '{"bucket": "bitcamp-assets"}' });

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 500);
    expect(JSON.parse(response.body).message).toBe('Missing event body parameters');
  });

  it('is missing event input', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions1.csv')));

    const response = await wrapped.run({});

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 500);
    expect(JSON.parse(response.body).message).toBe('Missing event body');
  });

  it('gives each team minimum time', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions5.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    const params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');
    // Checks if demo lengths are correct
    checkDemoLength(params.RequestItems['platform-test-expo-schedule'], MIN_TIME);
  });

  it('gives each team proportional time', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions6.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    const params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');
    // Checks if demo lengths are correct
    checkDemoLength(params.RequestItems['platform-test-expo-schedule'], 9);
  });

  it('gives each team proportional time with Math.floor', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions7.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    const params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');
    // Checks if demo lengths are correct
    // each length should calculate to 7.2 and become floored to 7
    checkDemoLength(params.RequestItems['platform-test-expo-schedule'], 7);
  });

  it('gives each team maximum time', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions8.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    const params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');
    // Checks if demo lengths are correct
    checkDemoLength(params.RequestItems['platform-test-expo-schedule'], MAX_TIME);
  });

  it('checks if team name is in demos', async () => {
    AwsMock.mock('S3', 'getObject',
      Buffer.from(fs.readFileSync('__tests__/inputs/submissions1.csv')));

    const response = await wrapped.run(
      { body: '{"bucket": "bitcamp-assets","submissionFileKey": "test.csv", "scheduleFileKey": "schedule.csv"}' },
    );

    expect(response).toBeDefined();
    expect(response).toHaveProperty('statusCode', 200);

    // Gets the parameters of the call to batchWrite (first call's first parameter)
    const params = uploadMock.mock.calls[0][0];
    // Check the data went to the right table
    expect(params.RequestItems).toHaveProperty('platform-test-expo-schedule');
    // Checks if there are demo names
    checkDemoNames(params.RequestItems['platform-test-expo-schedule']);
  });
});
